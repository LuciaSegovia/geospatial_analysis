ea_admin$region <- as.factor(ea_admin$region)
# Districts
dist_bnd  <- st_read(here::here( "data",
"mwi-boundaries",
"mwi_adm_nso_hotosm_20230329_shp",
"mwi_admbnda_adm2_nso_hotosm_20230329.shp"), quiet = TRUE)
dist_bnd <- st_make_valid(dist_bnd) # Check this
# Maize Se conc.(from cleaned from 00_cleaning-maize.R)
maize.df<- readRDS(here::here("data", "inter-output", "mwi-grain-se_raw.RDS")) %>%
## Getting only entries with maize Se values
filter(!is.na(Se_raw) & Crop == "Maize")
# Plasma Se conc. (cleaned from 00_cleaning-dhs.R)
plasma.df  <- readRDS(here::here("data", "inter-output","dhs_se_gps.rds")) %>%
# removing entries with missing values in plasma Se conc.
filter(!is.na(selenium))
# Removing lakes from boundaries dataset
# Selecting only variables that are interesting
# fid, EA code, TA name, TA code, district, dist code, EA area & geometry)
ea_admin <- ea_bnd %>% filter(!grepl("lake", DISTRICT,
ignore.case = TRUE)) %>%
dplyr::select(c(1, 4, 9, 10, 11, 12, 17, 18))
# Loop for adding the region Northern-Southern (1-3)
ea_admin$region <- NA
for(i in 1:3){
ea_admin$region[grepl(paste0("^", i), ea_admin$EACODE)] <- i
}
ea_admin %>% filter(is.na(region))
## Combining EAs with "authentic" District
ea_admin <-  st_join(ea_admin, dist_bnd)
ea_admin$ADM2_EN[is.na(ea_admin$ADM2_PCODE) & ea_admin$DISTRICT == "Mwanza"]
# Loading packages
library(spdep) # grid and neighbours
library(raster) # (spatial) raster data manipulation
library(dplyr) # data wrangling
library(stringr) # string data manipulation
library(ggplot2) # data visualisation
library(sf) # spatial data manipulation
library(tmap) # spatial data visualisation
library(DT) # pretty & interactive tables
# Loading data
# Admin Boundaries for Malawi: EAs
ea_bnd  <- st_read(here::here("data", "mwi-boundaries", "EN_NSO" , "eas_bnd.shp"),
quiet = TRUE)
# TAs
ta_bnd  <- st_read(here::here("data",
"mwi-boundaries",
"mwi_adm_nso_hotosm_20230329_shp",
"mwi_admbnda_adm3_nso_hotosm_20230329.shp"),
quiet = TRUE)
# Districts
dist_bnd  <- st_read(here::here( "data",
"mwi-boundaries",
"mwi_adm_nso_hotosm_20230329_shp",
"mwi_admbnda_adm2_nso_hotosm_20230329.shp"), quiet = TRUE)
dist_bnd <- st_make_valid(dist_bnd) # Check this
# Maize Se conc.(from cleaned from 00_cleaning-maize.R)
maize.df<- readRDS(here::here("data", "inter-output", "mwi-grain-se_raw.RDS")) %>%
## Getting only entries with maize Se values
filter(!is.na(Se_raw) & Crop == "Maize")
# Plasma Se conc. (cleaned from 00_cleaning-dhs.R)
plasma.df  <- readRDS(here::here("data", "inter-output","dhs_se_gps.rds")) %>%
# removing entries with missing values in plasma Se conc.
filter(!is.na(selenium))
# Removing lakes from boundaries dataset
# Selecting only variables that are interesting
# fid, EA code, TA name, TA code, district, dist code, EA area & geometry)
ea_admin <- ea_bnd %>% filter(!grepl("lake", DISTRICT,
ignore.case = TRUE)) %>%
dplyr::select(c(1, 4, 9, 10, 11, 12, 17, 18))
# Loop for adding the region Northern-Southern (1-3)
ea_admin$region <- NA
for(i in 1:3){
ea_admin$region[grepl(paste0("^", i), ea_admin$EACODE)] <- i
}
ea_admin %>% filter(is.na(region))
## Combining EAs with "authentic" District
ea_admin <-  st_join(ea_admin, dist_bnd)
tm_shape(ea_admin %>% filter(DISTRICT %in% "Mwanza")) +
tm_polygons(col = "black") +
tm_shape(dist_bnd %>% filter(ADM2_EN %in% "Mwanza")) +
tm_polygons("ADM2_EN", col_alpha = 0.1) +
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% ea_admin$EACODE[is.na(ea_admin$ADM2_PCODE) & ea_admin$DISTRICT == "Mwanza"]]) +
tm_polygons( fill = "red")
ea_admin$ADM2_EN[is.na(ea_admin$ADM2_PCODE) & ea_admin$DISTRICT == "Mwanza"] <- "Neno"
# Checking the class of the two datasets
class(ea_admin)
class(plasma.df)
# Getting only cluster location (to avoid duplicates)
geodata.df <- plasma.df %>% dplyr::select(survey_cluster1, buffer) %>%
distinct() %>%
# renaming buffer as geometry for converting into spatial object
dplyr::rename(geometry = "buffer") %>% st_sf(., crs = "EPSG:4326")
# Checking the effect of the line above
class(geodata.df)
# Getting info on the admin boundaries (EA/district level)
# Allocating buffered areas to each admin unit
geodata_ea <-  st_join(geodata.df, ea_admin)
geodata_ea$region <- as.factor(geodata_ea$region)
# Aggregate boundaries the whole country (with lakes)
malawi_bnd_lakes <- st_union(ea_bnd)
# Aggregate boundaries the whole country
malawi_bnd <- st_union(ea_admin)
tmap_mode("view")
# Generating the map
tm_shape(ea_admin) +
tm_polygons(fill = "white",
col = "#666666", col_alpha = 0.3, lwd = 0.2) +
tm_shape(malawi_bnd) +
tm_borders(col = "#666666", fill_alpha = 0.6, lwd = 0.5) +
tm_shape(malawi_bnd_lakes) +
tm_borders(col = "black", fill_alpha = 0.6, lwd = 0.5) +
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% unique(geodata_ea$EACODE)]) +
tm_polygons(fill ="firebrick4", col = "black", col_alpha = 0.3) +
tm_shape(geodata.df) +
tm_borders(col = "steelblue" )
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% unique(geodata_ea$EACODE)]) +
tm_polygons(fill ="firebrick4", col = "black", col_alpha = 0.3) +
tm_shape(geodata.df) +
tm_borders(col = "steelblue" )
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% unique(geodata_ea$EACODE)]) +
tm_polygons(fill ="firebrick4", col = "black", col_alpha = 0.3) +
tm_shape(geodata.df) +
tm_borders(col = "steelblue" )
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% unique(geodata_ea$EACODE)]) +
tm_polygons(fill ="firebrick4", col = "black", col_alpha = 0.3)
tm_shape(geodata.df) +
tm_borders(col = "steelblue" )
dist_bnd
geodata.df
tm_shape(geodata.df) +
tm_borders(col = "steelblue" )#
install.packages("leaflet.providers")
install.packages("leaflet.providers")
tm_shape(geodata.df) +
tm_borders(col = "steelblue" )
tm_shape(geodata.df) +
tm_borders(col = "steelblue" )
# Loading packages
library(spdep) # grid and neighbours
library(raster) # (spatial) raster data manipulation
library(dplyr) # data wrangling
library(stringr) # string data manipulation
library(ggplot2) # data visualisation
library(sf) # spatial data manipulation
library(tmap) # spatial data visualisation
library(DT) # pretty & interactive tables
tm_shape(geodata.df) +
tm_borders(col = "steelblue" )
tmap_mode("view")
tm_shape(geodata.df) +
tm_borders(col = "steelblue")
library(leafgl)
library(leaflet)
detach("package:leafgl", unload = TRUE)
detach("package:leaflet", unload = TRUE)
install.packages("leaflet")
install.packages("leaflet")
install.packages("leafgl")
# Loading packages
library(spdep) # grid and neighbours
library(raster) # (spatial) raster data manipulation
library(dplyr) # data wrangling
library(stringr) # string data manipulation
library(ggplot2) # data visualisation
library(sf) # spatial data manipulation
library(tmap) # spatial data visualisation
library(DT) # pretty & interactive tables
# Loading data
# Admin Boundaries for Malawi: EAs
ea_bnd  <- st_read(here::here("data", "mwi-boundaries", "EN_NSO" , "eas_bnd.shp"),
quiet = TRUE)
# TAs
ta_bnd  <- st_read(here::here("data",
"mwi-boundaries",
"mwi_adm_nso_hotosm_20230329_shp",
"mwi_admbnda_adm3_nso_hotosm_20230329.shp"),
quiet = TRUE)
# Districts
dist_bnd  <- st_read(here::here( "data",
"mwi-boundaries",
"mwi_adm_nso_hotosm_20230329_shp",
"mwi_admbnda_adm2_nso_hotosm_20230329.shp"), quiet = TRUE)
dist_bnd <- st_make_valid(dist_bnd) # Check this
# Maize Se conc.(from cleaned from 00_cleaning-maize.R)
maize.df<- readRDS(here::here("data", "inter-output", "mwi-grain-se_raw.RDS")) %>%
## Getting only entries with maize Se values
filter(!is.na(Se_raw) & Crop == "Maize")
# Plasma Se conc. (cleaned from 00_cleaning-dhs.R)
plasma.df  <- readRDS(here::here("data", "inter-output","dhs_se_gps.rds")) %>%
# removing entries with missing values in plasma Se conc.
filter(!is.na(selenium))
# Removing lakes from boundaries dataset
# Selecting only variables that are interesting
# fid, EA code, TA name, TA code, district, dist code, EA area & geometry)
ea_admin <- ea_bnd %>% filter(!grepl("lake", DISTRICT,
ignore.case = TRUE)) %>%
dplyr::select(c(1, 4, 9, 10, 11, 12, 17, 18))
# Loop for adding the region Northern-Southern (1-3)
ea_admin$region <- NA
for(i in 1:3){
ea_admin$region[grepl(paste0("^", i), ea_admin$EACODE)] <- i
}
ea_admin %>% filter(is.na(region))
## Combining EAs with "authentic" District
ea_admin <-  st_join(ea_admin, dist_bnd)
tm_shape(ea_admin %>% filter(DISTRICT %in% "Mwanza")) +
tm_polygons(col = "black") +
tm_shape(dist_bnd %>% filter(ADM2_EN %in% "Mwanza")) +
tm_polygons("ADM2_EN", col_alpha = 0.1) +
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% ea_admin$EACODE[is.na(ea_admin$ADM2_PCODE) & ea_admin$DISTRICT == "Mwanza"]]) +
tm_polygons( fill = "red")
ea_admin$ADM2_EN[is.na(ea_admin$ADM2_PCODE) & ea_admin$DISTRICT == "Mwanza"] <- "Neno"
# Checking the class of the two datasets
class(ea_admin)
class(plasma.df)
# Getting only cluster location (to avoid duplicates)
geodata.df <- plasma.df %>% dplyr::select(survey_cluster1, buffer) %>%
distinct() %>%
# renaming buffer as geometry for converting into spatial object
dplyr::rename(geometry = "buffer") %>% st_sf(., crs = "EPSG:4326")
# Checking the effect of the line above
class(geodata.df)
# Getting info on the admin boundaries (EA/district level)
# Allocating buffered areas to each admin unit
geodata_ea <-  st_join(geodata.df, ea_admin)
geodata_ea$region <- as.factor(geodata_ea$region)
# Aggregate boundaries the whole country (with lakes)
malawi_bnd_lakes <- st_union(ea_bnd)
malawi_bnd <- st_union(ea_admin)
malawi_bnd <- st_union(ea_admin)
tmap_mode("view")
tm_shape(geodata.df) +
tm_borders(col = "steelblue")
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% unique(geodata_ea$EACODE)]) +
tm_polygons(fill ="firebrick4", col = "black", col_alpha = 0.3) +
tm_shape(geodata.df) +
tm_borders(col = "steelblue")
tm_shape(malawi_bnd_lakes) +
tm_borders(col = "black", fill_alpha = 0.6, lwd = 0.5) +
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% unique(geodata_ea$EACODE)]) +
tm_polygons(fill ="firebrick4", col = "black", col_alpha = 0.3) +
tm_shape(geodata.df) +
tm_borders(col = "steelblue")
?tmap_mode
# Cluster data (cleaned from 00_cleaning-location.R)
cluster.df <- readRDS(here::here("data", "inter-output", "aggregation", "master-cluster-admin-level.RDS"))
# Loading packages
library(spdep) # grid and neighbours
library(raster) # (spatial) raster data manipulation
library(dplyr) # data wrangling
library(stringr) # string data manipulation
library(ggplot2) # data visualisation
library(sf) # spatial data manipulation
library(tmap) # spatial data visualisation
library(DT) # pretty & interactive tables
# Loading data
# Admin Boundaries for Malawi: EAs
ea_bnd  <- st_read(here::here("data", "mwi-boundaries", "EN_NSO" , "eas_bnd.shp"),
quiet = TRUE)
# TAs
ta_bnd  <- st_read(here::here("data",
"mwi-boundaries",
"mwi_adm_nso_hotosm_20230329_shp",
"mwi_admbnda_adm3_nso_hotosm_20230329.shp"),
quiet = TRUE)
# Districts
dist_bnd  <- st_read(here::here( "data",
"mwi-boundaries",
"mwi_adm_nso_hotosm_20230329_shp",
"mwi_admbnda_adm2_nso_hotosm_20230329.shp"), quiet = TRUE)
dist_bnd <- st_make_valid(dist_bnd) # Check this
# Maize Se conc.(from cleaned from 00_cleaning-maize.R)
maize.df<- readRDS(here::here("data", "inter-output", "mwi-grain-se_raw.RDS")) %>%
## Getting only entries with maize Se values
filter(!is.na(Se_raw) & Crop == "Maize")
# Plasma Se conc. (cleaned from 00_cleaning-dhs.R)
plasma.df  <- readRDS(here::here("data", "inter-output","dhs_se_gps.rds")) %>%
# removing entries with missing values in plasma Se conc.
filter(!is.na(selenium))
# Removing lakes from boundaries dataset
# Selecting only variables that are interesting
# fid, EA code, TA name, TA code, district, dist code, EA area & geometry)
ea_admin <- ea_bnd %>% filter(!grepl("lake", DISTRICT,
ignore.case = TRUE)) %>%
dplyr::select(c(1, 4, 9, 10, 11, 12, 17, 18))
# Loop for adding the region Northern-Southern (1-3)
ea_admin$region <- NA
for(i in 1:3){
ea_admin$region[grepl(paste0("^", i), ea_admin$EACODE)] <- i
}
ea_admin %>% filter(is.na(region))
## Combining EAs with "authentic" District
ea_admin <-  st_join(ea_admin, dist_bnd)
tm_shape(ea_admin %>% filter(DISTRICT %in% "Mwanza")) +
tm_polygons(col = "black") +
tm_shape(dist_bnd %>% filter(ADM2_EN %in% "Mwanza")) +
tm_polygons("ADM2_EN", col_alpha = 0.1) +
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% ea_admin$EACODE[is.na(ea_admin$ADM2_PCODE) & ea_admin$DISTRICT == "Mwanza"]]) +
tm_polygons( fill = "red")
ea_admin$ADM2_EN[is.na(ea_admin$ADM2_PCODE) & ea_admin$DISTRICT == "Mwanza"] <- "Neno"
# Checking the class of the two datasets
class(ea_admin)
class(plasma.df)
# Getting only cluster location (to avoid duplicates)
geodata.df <- plasma.df %>% dplyr::select(survey_cluster1, buffer) %>%
distinct() %>%
# renaming buffer as geometry for converting into spatial object
dplyr::rename(geometry = "buffer") %>% st_sf(., crs = "EPSG:4326")
# Checking the effect of the line above
class(geodata.df)
# Getting info on the admin boundaries (EA/district level)
# Allocating buffered areas to each admin unit
geodata_ea <-  st_join(geodata.df, ea_admin)
geodata_ea$region <- as.factor(geodata_ea$region)
# Aggregate boundaries the whole country (with lakes)
malawi_bnd_lakes <- st_union(ea_bnd)
# Aggregate boundaries the whole country
malawi_bnd <- st_union(ea_admin)
tmap_mode("view")
# Generating the map
tm_shape(ea_admin) +
tm_polygons(fill = "white",
col = "#666666", col_alpha = 0.3, lwd = 0.2) +
tm_shape(malawi_bnd) +
tm_borders(col = "#666666", fill_alpha = 0.6, lwd = 0.5) +
tm_shape(malawi_bnd_lakes) +
tm_borders(col = "black", fill_alpha = 0.6, lwd = 0.5) +
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% unique(geodata_ea$EACODE)]) +
tm_polygons(fill ="firebrick4", col = "black", col_alpha = 0.3) +
tm_shape(geodata.df) +
tm_borders(col = "steelblue")# +
# Loading packages
library(spdep) # grid and neighbours
library(raster) # (spatial) raster data manipulation
library(dplyr) # data wrangling
library(stringr) # string data manipulation
library(ggplot2) # data visualisation
library(sf) # spatial data manipulation
library(tmap) # spatial data visualisation
library(DT) # pretty & interactive tables
# Loading data
# Admin Boundaries for Malawi: EAs
ea_bnd  <- st_read(here::here("data", "mwi-boundaries", "EN_NSO" , "eas_bnd.shp"),
quiet = TRUE)
# TAs
ta_bnd  <- st_read(here::here("data",
"mwi-boundaries",
"mwi_adm_nso_hotosm_20230329_shp",
"mwi_admbnda_adm3_nso_hotosm_20230329.shp"),
quiet = TRUE)
# Districts
dist_bnd  <- st_read(here::here( "data",
"mwi-boundaries",
"mwi_adm_nso_hotosm_20230329_shp",
"mwi_admbnda_adm2_nso_hotosm_20230329.shp"), quiet = TRUE)
dist_bnd <- st_make_valid(dist_bnd) # Check this
# Maize Se conc.(from cleaned from 00_cleaning-maize.R)
maize.df<- readRDS(here::here("data", "inter-output", "mwi-grain-se_raw.RDS")) %>%
## Getting only entries with maize Se values
filter(!is.na(Se_raw) & Crop == "Maize")
# Plasma Se conc. (cleaned from 00_cleaning-dhs.R)
plasma.df  <- readRDS(here::here("data", "inter-output","dhs_se_gps.rds")) %>%
# removing entries with missing values in plasma Se conc.
filter(!is.na(selenium))
# Removing lakes from boundaries dataset
# Selecting only variables that are interesting
# fid, EA code, TA name, TA code, district, dist code, EA area & geometry)
ea_admin <- ea_bnd %>% filter(!grepl("lake", DISTRICT,
ignore.case = TRUE)) %>%
dplyr::select(c(1, 4, 9, 10, 11, 12, 17, 18))
# Loop for adding the region Northern-Southern (1-3)
ea_admin$region <- NA
for(i in 1:3){
ea_admin$region[grepl(paste0("^", i), ea_admin$EACODE)] <- i
}
ea_admin %>% filter(is.na(region))
## Combining EAs with "authentic" District
ea_admin <-  st_join(ea_admin, dist_bnd)
tm_shape(ea_admin %>% filter(DISTRICT %in% "Mwanza")) +
tm_polygons(col = "black") +
tm_shape(dist_bnd %>% filter(ADM2_EN %in% "Mwanza")) +
tm_polygons("ADM2_EN", col_alpha = 0.1) +
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% ea_admin$EACODE[is.na(ea_admin$ADM2_PCODE) & ea_admin$DISTRICT == "Mwanza"]]) +
tm_polygons( fill = "red")
ea_admin$ADM2_EN[is.na(ea_admin$ADM2_PCODE) & ea_admin$DISTRICT == "Mwanza"] <- "Neno"
# Checking the class of the two datasets
class(ea_admin)
class(plasma.df)
# Getting only cluster location (to avoid duplicates)
geodata.df <- plasma.df %>% dplyr::select(survey_cluster1, buffer) %>%
distinct() %>%
# renaming buffer as geometry for converting into spatial object
dplyr::rename(geometry = "buffer") %>% st_sf(., crs = "EPSG:4326")
# Checking the effect of the line above
class(geodata.df)
# Getting info on the admin boundaries (EA/district level)
# Allocating buffered areas to each admin unit
geodata_ea <-  st_join(geodata.df, ea_admin)
geodata_ea$region <- as.factor(geodata_ea$region)
# Aggregate boundaries the whole country (with lakes)
malawi_bnd_lakes <- st_union(ea_bnd)
# Aggregate boundaries the whole country
malawi_bnd <- st_union(ea_admin)
tmap_mode("view")
# Generating the map
tm_shape(ea_admin) +
tm_polygons(fill = "white",
col = "#666666", col_alpha = 0.3, lwd = 0.2) +
tm_shape(malawi_bnd) +
tm_borders(col = "#666666", fill_alpha = 0.6, lwd = 0.5) +
tm_shape(malawi_bnd_lakes) +
tm_borders(col = "black", fill_alpha = 0.6, lwd = 0.5) +
tm_shape(ea_admin$geometry[ea_admin$EACODE %in% unique(geodata_ea$EACODE)]) +
tm_polygons(fill ="firebrick4", col = "black", col_alpha = 0.3) +
tm_shape(geodata.df) +
tm_borders(col = "steelblue")# +
#tm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))
tmap_mode("plot")
# Checking the EAs per buffer and district
(g1 <- geodata_ea %>%  st_drop_geometry() %>%
mutate_at("survey_cluster1", as.character) %>%
ggplot(aes(x=reorder(survey_cluster1, survey_cluster1, function(x)-length(x)))) +
geom_bar(aes(fill = DISTRICT)) +
theme_bw() +
labs(
x = "Cluster") +
scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
theme(strip.text = element_text(size = 12),
axis.text.y = element_text(size = 12),
axis.text.x = element_text(size = 10, angle =30)))
g1 +
facet_wrap(~region, labeller = as_labeller(c(`1` = "Northern",
`2` = "Central",
`3` = "Southern")),
scales = "free_x") +
theme(legend.position="top")
# Checking the districts in plasma dataset
# Converting back from spatial obj to dataframe
plasma.df  <- geodata_ea  %>% st_drop_geometry()  %>%  # removing geometry
right_join(., plasma.df, relationship = "many-to-many")  # multiple EAs per cluster,                                                         multiple WRA per cluster.
# New variable to check the correct district (based on survey)
plasma.df$dist_name2 <- as.character(plasma.df$dist_name)
# Changing the spelling to fit the NSO boundaries file
plasma.df$dist_name2 <- gsub("nkhota kota", "nkhotakota", plasma.df$dist_name2)
plasma.df$dist_name2 <- gsub("lilongwe rural", "lilongwe", plasma.df$dist_name2)
plasma.df$dist_name2 <- gsub("ndanje", "nsanje", plasma.df$dist_name2)
plasma.df$dist_name2 <- gsub("zomba rural", "zomba", plasma.df$dist_name2)
plasma.df$dist_name2 <- gsub("blantyre rural", "blantyre", plasma.df$dist_name2)
plasma.df$dist_name2 <- gsub("mulange", "mulanje", plasma.df$dist_name2)
plasma.df$dist_name2 <- gsub("chradzulu", "chiradzulu", plasma.df$dist_name2)
# Dummy variable to check whether districts are the same or not
plasma.df$boundaries_check <- ifelse(tolower(plasma.df$ADM2_EN) == plasma.df$dist_name2, TRUE, FALSE)
# Checking district that are the same and those with NA (some dist_name were NA)
plasma.df %>%  dplyr::filter(boundaries_check == TRUE | is.na(boundaries_check) ) %>%
select(survey_cluster1, ADM2_EN, dist_name2, boundaries_check) %>% distinct() %>%
# Changing the class of the cluster for table improvement
mutate_at("survey_cluster1", as.character) %>%
# Make the interactive table
datatable(., filter = "top")
# Showing the table with the EACODEs and the "wrong" districts
plasma.df %>% dplyr::filter(boundaries_check == FALSE) %>%
select(survey_cluster1, EACODE, ADM2_EN, dist_name2, boundaries_check) %>%
distinct()  %>%
# Changing the class of the cluster for table improvement
mutate_at("survey_cluster1", as.character) %>%
# Make the interactive table
datatable(., filter = "top")
# Getting the cluster and corresponding district
district <- plasma.df %>% dplyr::filter(boundaries_check == TRUE) %>%
distinct(survey_cluster1, ADM2_EN)
# Then we check that we have all the cluster covered
length(unique(plasma.df$survey_cluster1))- length(unique(district$survey_cluster1))
# knitr::kable(district)
# Checking Likoma in plasma dataset
plasma.df %>% dplyr::filter(dist_name2 == "likoma") %>%
select(survey_cluster1, ADM2_EN, dist_name2) %>% distinct()
# Checking Zomba in plasma dataset
plasma.df %>% dplyr::filter(dist_name2 == "zomba") %>%
select(survey_cluster1, urbanity) %>% distinct()
# Checking Zomba City in plasma dataset
plasma.df %>% dplyr::filter(ADM2_EN == "Zomba City") %>%
select(survey_cluster1, EACODE, ADM2_EN, dist_name2, urbanity) %>% distinct()
# Checking Zomba City in plasma dataset
plasma.df %>% dplyr::filter(dist_name2 == "zomba") %>%
select(survey_cluster1, EACODE, ADM2_EN, dist_name2, urbanity) %>% distinct()
# Generating the map
tm_shape(dist_bnd) +
tm_polygons(fill = "white",
col = "#666666", col_alpha = 0.3, lwd = 0.2) +
tm_shape(malawi_bnd) +
tm_borders(col = "#666666", fill_alpha = 0.6, lwd = 0.5) +
tm_shape(malawi_bnd_lakes) +
tm_borders(col = "black", fil_alpha = 0.6, lwd = 0.5) +
tm_shape(ea_admin %>% filter(grepl("Zomba",ADM2_EN))) +
tm_polygons(fill ="ADM2_EN", col = "black", col_alpha = 0.3)
# Excluding EAs that were not with the corresponding district for each cluster
plasma.df <- left_join(district, plasma.df)
# Checking Zomba City in plasma dataset
plasma.df %>% dplyr::filter(ADM2_EN == "Zomba City") %>%
select(survey_cluster1, EACODE, ADM2_EN, dist_name2, urbanity) %>% distinct()
# Saving the master file with the survey cluster (id) and the admin level
# EAs, districts, and regions.
plasma.df %>% distinct(survey_cluster1, EACODE, urbanity,
ADM2_PCODE, ADM2_EN, ADM1_PCODE, ADM1_EN) %>%
filter(!is.na(ADM1_EN))  %>% # Only one NA as per above
saveRDS(here::here("data", "inter-output", "aggregation", "master-cluster-admin-level.RDS"))
# Cluster data (cleaned from 00_cleaning-location.R)
cluster.df <- readRDS(here::here("data", "inter-output", "aggregation", "master-cluster-admin-level.RDS"))
quatro::check
quatro check.options()
check.options()
View(geodata.df)
