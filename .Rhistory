xrange <- range(sapply(models, function(x) range(x$marginals.fix[[1]][,1])))
yrange <- range(sapply(models, function(x) range(x$marginals.fix[[1]][,2])))
plot(models[[1]]$marginals.fix[[1]], type='l', xlim=xrange, ylim=yrange,
# xlab=expression(beta[0]), ylab='Density')
xlab=expression(alpha[c]), ylab='Density')
for (k in 1:length(models))
lines(models[[k]]$marginals.fix[[1]], col=rcols[k], lwd=2)
xrange <- range(sapply(s2.marg, function(x) range(x[,1])))
s2.marg <- lapply(models, function(m) inla.tmarginal(function(x) 1/x, m$marginals.hy[[1]]))
xrange <- range(sapply(s2.marg, function(x) range(x[,1])))
yrange <- range(sapply(s2.marg, function(x) range(x[,2])))
plot.default(s2.marg[[k]], type='l', xlim=xrange,
ylim=yrange, xlab=expression(sigma[e]^2), ylab='Density')
for (k in 1:length(models))
lines(s2.marg[[k]], col=rcols[k], lwd=2)
plot(pmd.s2e[[4]], type='l', ylab='Density', xlab=expression(sigma[e]))
for (k in 1:length(models))
lines(pmd.s2e[[k]], col=rcols[k], lwd=2, ylab='Density', xlab=expression(sigma[e]))
models[[1$marginals.hyperpar$'Precision for the Gaussian observations']]
models[[1]]$marginals.hyperpar$'Precision for the Gaussian observations']]
models[[1]]$marginals.hyperpar$'Precision for the Gaussian observations'
models[[1]]$marginals.hyperpar[[1]]
xrange <- range(sapply(spde.est, function(r) range(r$marginals.variance.nominal[[1]][,1])))
yrange <- range(sapply(spde.est, function(r) range(r$marginals.variance.nominal[[1]][,2])))
plot(spde.est[[1]]$marginals.variance.nominal[[1]], type='l', xlim=xrange, ylim=yrange,
# xlab=expression(sigma[x]^2), ylab='Density')
xlab=expression(sigma[omega]^2), ylab='Density')
for (k in 1:length(models))
lines(spde.est[[k]]$marginals.variance.nominal[[1]], col=rcols[k], lwd=2)
INLADICFig(models[c(1:10)]) + theme_bw() +
# scale_x_discrete(labels= modelNames[1:10]) +
theme(legend.position = "none",
strip.text = element_text(size = 12),
axis.text.y = element_text(size = 12),
axis.text.x = element_text(size = 10))
#DIC
models[[9]]$dic$dic
#DIC
models[[8]]$dic$dic
source("C:/Users/LuciaSegoviaDeLaRevi/OneDrive - London School of Hygiene and Tropical Medicine/PhD/PhD_r-project/PhD_geospatial-modelling/code/02_inla-loop.R", echo=TRUE)
# Viz
rcols <- rainbow(10) ##c(rgb(4:1/4,0:3/5,0), c(rgb(0,0:3/5,4:1/4)))
par(mfrow=c(1,3), mar=c(2.5,2.5,1,.5), mgp=c(1.5,.5,0), las=1)
#Extracting the SPDE results for all the models
spde.est <- lapply(models, function(m) inla.spde2.result(m, name = "spatial.field",
spde = spde, do.transf = TRUE))
xrange <- range(sapply(spde.est, function(r) range(r$marginals.tau[[1]][,1])))
yrange <- range(sapply(spde.est, function(r) range(r$marginals.tau[[1]][,2])))
plot(spde.est[[1]]$marginals.tau[[1]], type='l', xlim=xrange, ylim=yrange, xlab=expression(tau), ylab='Density')
for (k in 1:length(models))
lines(spde.est[[k]]$marginals.tau[[1]], col=rcols[k], lwd=2)
legend('topright', c(paste('buffer',1:8, sep=''), 'cluster', 'district'),
lty=c(rep(1,10), 2, 3), lwd=rep(2, 10), col=c(rcols), bty='n')
2/10
plot(pmd.s2e[[4]], type='l', ylab='Density', xlab=expression(sigma[e]))
# Testing...
pmd.s2e <- lapply(models, function(m) inla.tmarginal(function(x) sqrt(1/x), ## inverse and square root
m$marginals.hyperpar$'Precision for the Gaussian observations'))
plot(pmd.s2e[[4]], type='l', ylab='Density', xlab=expression(sigma[e]))
for (k in 1:length(models))
lines(pmd.s2e[[k]], col=rcols[k], lwd=2, ylab='Density', xlab=expression(sigma[e]))
plot(models[[7]]$marginals.hy[[3]], type='l', xlab=expression(sigma[u]), ylab='Density')
for (k in 1:length(models))
lines(models[[k]]$marginals.hy[[3]], col=rcols[k], lwd=2, xlab=expression(sigma[u]), ylab='Density')
abline(v=sqrt(22), col=2) ## add the 'true' value
abline(v=sqrt(21), col=2) ## add the 'true' value
exp(3)
abline(v=sqrt(20), col=2) ## add the 'true' value
abline(v=sqrt(18), col=2) ## add the 'true' value
sqrt(18)
sqrt(2)
exp(2)
abline(v=sqrt(8), col=2) ## add the 'true' value
abline(v=sqrt(5), col=2) ## add the 'true' value
abline(v=sqrt(1), col=2) ## add the 'true' value
# Loading libraries and functions
library(dplyr) # data wrangling
library(ggplot2) # visualisation
library(sf) #spatial data manipulation
library(tmap)  #spatial data manipulation and visualisation
source(here::here("functions", "CEPHaStat_3.R")) #stat functions
# Skewness[-1,+1], Octile skewness [âˆ’0.2,0.2]
library(geoR)  # geospatial modelling
library(geosphere) # spatial functions for variogram
## Loading data ----
# Plasma Se conc. (cleaned from 00_cleaning-dhs.R)
plasma.df  <- readRDS(here::here("data", "inter-output","dhs_se_gps.rds")) %>% # cleaned geo-loc plasma Se data
filter(!is.na(selenium)) # %>% select(1:48) # removing buffer and other spatial vars
names(plasma.df)
data.df <- plasma.df %>% dplyr::select(selenium, Latitude, Longitude)
######################################################################################################################
#
#  Exploratory study of empirical variogram
#
#  Make a variogram cloud
#
N<-nrow(data.df)
NP<-0.5*N*(N-1)
Long<-data.df$Longitude
Lat<-data.df$Latitude
z<-data.df$selenium
lag<-vector("numeric",NP)
vclo<-vector("numeric",NP)
bear<-vector("numeric",NP)
ico=0
for (i in 1:(N-1)){
for (j in (i+1):N){
ico=ico+1
print(ico/NP)
lag[ico]<-distVincentySphere(c(Long[i],Lat[i]),c(Long[j],Lat[j]))/1000 #
bear[ico]<-finalBearing(c(Long[i],Lat[i]),c(Long[j],Lat[j]), a=6378137, f=1/298.257223563, sphere=TRUE)
zi<-(z[i])
zj<-(z[j])
vclo[ico]<-(zi-zj)
}
}
lagbins<-cut(lag,seq(0,200,10),labels=seq(1,200,10))   # 10-km bins for Malawi
lag2<-lag[!is.na(lagbins)]
vclo2<-vclo[!is.na(lagbins)]
lagbins<-factor(lagbins[!is.na(lagbins)])
nlags<-nlevels(lagbins)
####################################################
# Form estimates of the variogram
# Matrices in which to keep, for the lag bins in lagbins:
#  i. semiv - variogram estimates, fifth column is isotropic Matheron, columns
#  1 to 4 are directional (Matheron estimator), columns 6 and 7 are isotropic
#  estimates with Cressie-Hawkins and Dowd estimators respectively.
#
#  ii. npair and varlags - respectively the number of lag pairs per bin, and the mean
#	lag distance.  Columns 1 to 4 are directional (as in semiv) and 5 is isotropic.
semiv<-matrix(nrow=nlags,ncol=7)
npair<-matrix(nrow=nlags,ncol=5)
varlags<-matrix(nrow=nlags,ncol=5)
colnames(semiv)<-c("N-S,Ma","NE-SW,Ma","W-E,Ma","SE-NW,Ma","iso-Ma","iso-CH","iso-Do")
colnames(varlags)<-c("N-S","NE-SW","W-E","SE-NW","iso")
colnames(npair)<-c("N-S","NE-SW","W-E","SE-NW","iso")
varlags[,5]<-as.numeric(by(lag2, lagbins, mean))
npair[,5]<-as.numeric(by(lag2, lagbins, sum))/as.numeric(by(lag2, lagbins, mean))
#
# estimator
#
#  Matheron
semiv[,5]<-0.5*(as.numeric(by((vclo2)^2, lagbins, mean)))
# CH
semiv[,6]<-(as.numeric(by((sqrt(abs(vclo2))), lagbins, mean)))^4
semiv[,6]<-0.5*semiv[,6]/(0.457+0.459/npair[,5]+0.045/npair[,5]^2)
# Do
vclo2d<-c(vclo2,-vclo2)
lagbinsd<-c(lagbins,lagbins)
semiv[,7]<-0.5*(as.numeric(by(vclo2d, lagbinsd, mad)))^2
####################################################
#  Now plot the variograms
maxv<-max(semiv[,5:7])
minv<-min(semiv[,5:7])
maxv
minv
abline(v=sqrt(2.6), col=2) ## add the 'true' value
plot(models[[7]]$marginals.hy[[3]], type='l', xlab=expression(sigma[u]), ylab='Density')
for (k in 1:length(models))
lines(models[[k]]$marginals.hy[[3]], col=rcols[k], lwd=2, xlab=expression(sigma[u]), ylab='Density')
abline(v=sqrt(2.6), col=2) ## add the 'true' value
coordinates(data.df) <- ~Longitude+Latitude
proj4string(data.df) <- CRS("+init=epsg:4326")
# Variogram and fit variogram
vgm <- variogram(selenium ~1, data.df)
library(geosphere) # spatial functions for variogram
# Variogram and fit variogram
vgm <- variogram(selenium ~1, data.df)
library("gstat")
library(gstat)
install.packages("gstat")
coordinates(data.df) <- ~Longitude+Latitude
proj4string(data.df) <- CRS("+init=epsg:4326")
# Variogram and fit variogram
vgm <- variogram(selenium ~1, data.df)
fit.variogram(v, vgm(c("Exp", "Sph")))
library(gstat) # variogram function
# Variogram and fit variogram
vgm <- variogram(selenium ~1, data.df)
fit.variogram(v, vgm(c("Exp", "Sph")))
# Variogram and fit variogram
v <- variogram(selenium ~1, data.df)
fit.variogram(v, vgm(c("Exp", "Sph")))
fit.variogram(v, vgm(c("Exp", "Sph")), fit.kappa = TRUE))
fit.variogram(v, vgm(c("Exp", "Sph")), fit.kappa = TRUE)
fit.variogram(v, vgm(c("Exp", "Sph")), fit.kappa = TRUE)
fit.variogram(v, vgm("Exp"))
max(semiv[,5:7])
min(semiv[,5:7])
mean(semiv[,5:7])
# Variogram and fit variogram
v <- variogram(log(selenium) ~1, data.df)
fit.variogram(v, vgm(c("Exp", "Sph")), fit.kappa = TRUE)
plot(variogramLine(vgm(1, "Mat", 1, kappa = 4), 10), type = 'l')
plot(v)
maxv<-max(semiv[,5:7])
minv<-min(semiv[,5:7])
plot(varlags[,5],semiv[,5],ylim=c(0,maxv),xlab="Distance /km",ylab="Variance",pch=16)
#plot(varlags[,5],semiv[,6],ylim=c(0,maxv),xlab="Distance /km",ylab="Variance",pch=16)
points(varlags[,5],semiv[,6],pch=1, col ="blue")
points(varlags[,5],semiv[,7],pch=17,col = "red")
abline(v=110)
locsv<-minv*c(0.6,0.4,0.2)
points(60,locsv[1],pch=16)
points(60,locsv[2],pch=1 , col ="blue")
points(60,locsv[3],pch=17, col = "red")
text(65,locsv[1],"Matheron",pos=4)
text(65,locsv[2],"Cressie-Hawkins",pos=4)
text(65,locsv[3],"Dowd",pos=4)
par(mfrow=c(1,1))
maxv<-max(semiv[,5:7])
minv<-min(semiv[,5:7])
plot(varlags[,5],semiv[,5],ylim=c(0,maxv),xlab="Distance /km",ylab="Variance",pch=16)
#plot(varlags[,5],semiv[,6],ylim=c(0,maxv),xlab="Distance /km",ylab="Variance",pch=16)
points(varlags[,5],semiv[,6],pch=1, col ="blue")
points(varlags[,5],semiv[,7],pch=17,col = "red")
abline(v=110)
locsv<-minv*c(0.6,0.4,0.2)
points(60,locsv[1],pch=16)
points(60,locsv[2],pch=1 , col ="blue")
points(60,locsv[3],pch=17, col = "red")
text(65,locsv[1],"Matheron",pos=4)
text(65,locsv[2],"Cressie-Hawkins",pos=4)
text(65,locsv[3],"Dowd",pos=4)
plot(v)
abline(v=110)
abline(v=110)
hist(data.df$selenium)
summaplot(data.df$selenium)
summaplot(log(data.df$selenium))
######################################################################################################################
#
#  Exploratory study of empirical variogram
#
#  Make a variogram cloud
#
N<-nrow(data.df)
NP<-0.5*N*(N-1)
Long<-data.df$Longitude
Lat<-data.df$Latitude
#z<-data.df$selenium
z<-log(data.df$selenium)
lag<-vector("numeric",NP)
vclo<-vector("numeric",NP)
bear<-vector("numeric",NP)
ico=0
for (i in 1:(N-1)){
for (j in (i+1):N){
ico=ico+1
print(ico/NP)
lag[ico]<-distVincentySphere(c(Long[i],Lat[i]),c(Long[j],Lat[j]))/1000 #
bear[ico]<-finalBearing(c(Long[i],Lat[i]),c(Long[j],Lat[j]), a=6378137, f=1/298.257223563, sphere=TRUE)
zi<-(z[i])
zj<-(z[j])
vclo[ico]<-(zi-zj)
}
}
lagbins<-cut(lag,seq(0,200,10),labels=seq(1,200,10))   # 10-km bins for Malawi
lag2<-lag[!is.na(lagbins)]
vclo2<-vclo[!is.na(lagbins)]
lagbins<-factor(lagbins[!is.na(lagbins)])
nlags<-nlevels(lagbins)
####################################################
# Form estimates of the variogram
# Matrices in which to keep, for the lag bins in lagbins:
#  i. semiv - variogram estimates, fifth column is isotropic Matheron, columns
#  1 to 4 are directional (Matheron estimator), columns 6 and 7 are isotropic
#  estimates with Cressie-Hawkins and Dowd estimators respectively.
#
#  ii. npair and varlags - respectively the number of lag pairs per bin, and the mean
#	lag distance.  Columns 1 to 4 are directional (as in semiv) and 5 is isotropic.
semiv<-matrix(nrow=nlags,ncol=7)
npair<-matrix(nrow=nlags,ncol=5)
varlags<-matrix(nrow=nlags,ncol=5)
colnames(semiv)<-c("N-S,Ma","NE-SW,Ma","W-E,Ma","SE-NW,Ma","iso-Ma","iso-CH","iso-Do")
colnames(varlags)<-c("N-S","NE-SW","W-E","SE-NW","iso")
colnames(npair)<-c("N-S","NE-SW","W-E","SE-NW","iso")
varlags[,5]<-as.numeric(by(lag2, lagbins, mean))
npair[,5]<-as.numeric(by(lag2, lagbins, sum))/as.numeric(by(lag2, lagbins, mean))
#
# estimator
#
#  Matheron
semiv[,5]<-0.5*(as.numeric(by((vclo2)^2, lagbins, mean)))
# CH
semiv[,6]<-(as.numeric(by((sqrt(abs(vclo2))), lagbins, mean)))^4
semiv[,6]<-0.5*semiv[,6]/(0.457+0.459/npair[,5]+0.045/npair[,5]^2)
# Do
vclo2d<-c(vclo2,-vclo2)
lagbinsd<-c(lagbins,lagbins)
semiv[,7]<-0.5*(as.numeric(by(vclo2d, lagbinsd, mad)))^2
####################################################
#  Now plot the variograms
maxv<-max(semiv[,5:7])
minv<-min(semiv[,5:7])
plot(varlags[,5],semiv[,5],ylim=c(0,maxv),xlab="Distance /km",ylab="Variance",pch=16)
#plot(varlags[,5],semiv[,6],ylim=c(0,maxv),xlab="Distance /km",ylab="Variance",pch=16)
points(varlags[,5],semiv[,6],pch=1, col ="blue")
points(varlags[,5],semiv[,7],pch=17,col = "red")
abline(v=110)
locsv<-minv*c(0.6,0.4,0.2)
points(60,locsv[1],pch=16)
points(60,locsv[2],pch=1 , col ="blue")
points(60,locsv[3],pch=17, col = "red")
text(65,locsv[1],"Matheron",pos=4)
text(65,locsv[2],"Cressie-Hawkins",pos=4)
text(65,locsv[3],"Dowd",pos=4)
# kappa
xrange <- range(sapply(spde.est, function(r) range(r$marginals.kappa[[1]][,1])))
yrange <- range(sapply(spde.est, function(r) range(r$marginals.kappa[[1]][,2])))
plot(spde.est[[1]]$marginals.kappa[[1]], type='l', xlim=xrange, ylim=yrange,
xlab=expression(kappa), ylab='Density')
for (k in 1:length(models))
lines(spde.est[[k]]$marginals.kappa[[1]], col=rcols[k], lwd=2)
# Testing...
pmd.s2e <- lapply(models, function(m) inla.tmarginal(function(x) sqrt(1/x), ## inverse and square root
m$marginals.hyperpar$'Precision for the Gaussian observations'))
# Error term (noise or nugget effect)
plot(pmd.s2e[[1]], type='l', ylab='Density', xlab=expression(sigma[e]))
plot(pmd.s2e[[4]], type='l', ylab='Density', xlab=expression(sigma[e]))
for (k in 1:length(models))
lines(pmd.s2e[[k]], col=rcols[k], lwd=2, ylab='Density', xlab=expression(sigma[e]))
# abline(v=sqrt(s2e), col=2) ## add the 'true' value
require(geoR)
lkf <- likfit(as.geodata(plasma_se), ini=c(100, 1/21), kappa=21, ### kappa in geoR is nu
nugget=50, messages=FALSE)
plasma_se$Plasma_Se
plasma_se$Plasma_Se <- log(plasma_se$Plasma_Se)
names(plasma_se)
lkf <- likfit(as.geodata(plasma_se), ini=c(100, 1/21), kappa=21, ### kappa in geoR is nu
nugget=50, messages=FALSE)
Plasma_se[, c("Plasma_Se", "Se_mean", "Latitude","Longitude"  )]
plasma_se[, c("Plasma_Se", "Se_mean", "Latitude","Longitude")]
test <- plasma_se[, c("Plasma_Se", "Se_mean", "Latitude","Longitude")]
lkf <- likfit(as.geodata(test), ini=c(100, 1/21), kappa=21, ### kappa in geoR is nu
nugget=50, messages=FALSE)
lkf
test <- na.omit(plasma_se[, c("Plasma_Se", "Se_mean", "Latitude","Longitude")])
lkf <- likfit(as.geodata(test), ini=c(100, 1/21), kappa=21, ### kappa in geoR is nu
nugget=50, messages=FALSE)
lkf <- likfit(as.geodata(test), ini=c(21, 1/100), kappa=100, ### kappa in geoR is nu
nugget=50, messages=FALSE)
test
plasma_se$Se_mean <- plasma_se$Se_mean/100
lkf <- likfit(as.geodata(test), ini=c(21, 1/100), kappa=100, ### kappa in geoR is nu
nugget=50, messages=FALSE)
lkf <- likfit(as.geodata(test), ini=c(0.5, 1/1.1), kappa=1.1, ### kappa in geoR is nu
nugget=0.05, messages=FALSE)
lkf$nugget
xrange <- range(sapply(s2.marg, function(x) range(x[,1])))
plot(pmd.s2e[[4]], type='l', ylab='Density', xlab=expression(sigma[e]))
for (k in 1:length(models))
lines(pmd.s2e[[k]], col=rcols[k], lwd=2, ylab='Density', xlab=expression(sigma[e]))
# abline(v=sqrt(s2e), col=2) ## add the 'true' value
plot(pmd.s2e[[4]], type='l', ylab='Density', xlab=expression(sigma[e]))
for (k in 1:length(models))
lines(pmd.s2e[[k]], col=rcols[k], lwd=2, ylab='Density', xlab=expression(sigma[e]))
abline(v=sqrt(0.3799046), col=2) ## add the 'true' value
abline(v=sqrt(0.3799046), col=2) ## add the 'true' value
sqrt(0.3799046)
lkf$sigmasq
plot(models[[7]]$marginals.hy[[3]], type='l', xlab=expression(sigma[u]), ylab='Density')
for (k in 1:length(models))
lines(models[[k]]$marginals.hy[[3]], col=rcols[k], lwd=2, xlab=expression(sigma[u]), ylab='Density')
abline(v=sqrt(225.95), col=2) ## add the 'true' value
plot(models[[4]]$marginals.hy[[2]], type='l', xlab='range nominal', ylab='Density')
for (k in 1:length(models))
lines(models[[k]]$marginals.hy[[2]], col=rcols[k], lwd=2, xlab='range nominal', ylab='Density')
abline(v=r*100, col=2) ## add the 'true' value
legend('topright', c(paste('buffer',1:8, sep=''), 'cluster', 'district'),
lty=c(rep(1,10), 2, 3), lwd=rep(2, 10), col=c(rcols), bty='n')
1/lkf$phi
# kappa
xrange <- range(sapply(spde.est, function(r) range(r$marginals.kappa[[1]][,1])))
yrange <- range(sapply(spde.est, function(r) range(r$marginals.kappa[[1]][,2])))
plot(spde.est[[1]]$marginals.kappa[[1]], type='l', xlim=xrange, ylim=yrange,
xlab=expression(kappa), ylab='Density')
for (k in 1:length(models))
lines(spde.est[[k]]$marginals.kappa[[1]], col=rcols[k], lwd=2)
lkf <- likfit(as.geodata(test), ini=c(1, #sigma (s2x)
1/1 # 1/kappa
), kappa=1, ### kappa in geoR is nu
# sigma (s2e)
nugget=0.05, messages=FALSE)
rbind(geoR=c(lkf$beta, lkf$nugget, lkf$sigmasq, 1/lkf$phi))
# Cleaning the environment
rm(list = ls())
# Loading libraries and functions
library(dplyr) # data wrangling
library(ggplot2) # visualisation
library(sf) #spatial data manipulation
library(tmap)  #spatial data manipulation and visualisation
source(here::here("functions", "CEPHaStat_3.R")) #stat functions
# Skewness[-1,+1], Octile skewness [âˆ’0.2,0.2]
library(geoR)  # geospatial modelling
library(geosphere) # spatial functions for variogram
library(gstat) # variogram function
## Loading data ----
# Plasma Se conc. (cleaned from 00_cleaning-dhs.R)
plasma.df  <- readRDS(here::here("data", "inter-output","dhs_se_gps.rds")) %>% # cleaned geo-loc plasma Se data
filter(!is.na(selenium)) # %>% select(1:48) # removing buffer and other spatial vars
names(plasma.df)
data.df <- plasma.df %>% dplyr::select(selenium, Latitude, Longitude)
hist(data.df$selenium)
summaplot(data.df$selenium)
summaplot(log(data.df$selenium))
######################################################################################################################
#
#  Exploratory study of empirical variogram
#
#  Make a variogram cloud
#
N<-nrow(data.df)
NP<-0.5*N*(N-1)
Long<-data.df$Longitude
Lat<-data.df$Latitude
#z<-data.df$selenium
z<-log(data.df$selenium)
lag<-vector("numeric",NP)
vclo<-vector("numeric",NP)
bear<-vector("numeric",NP)
ico=0
for (i in 1:(N-1)){
for (j in (i+1):N){
ico=ico+1
print(ico/NP)
lag[ico]<-distVincentySphere(c(Long[i],Lat[i]),c(Long[j],Lat[j]))/1000 #
bear[ico]<-finalBearing(c(Long[i],Lat[i]),c(Long[j],Lat[j]), a=6378137, f=1/298.257223563, sphere=TRUE)
zi<-(z[i])
zj<-(z[j])
vclo[ico]<-(zi-zj)
}
}
lagbins<-cut(lag,seq(0,200,10),labels=seq(1,200,10))   # 10-km bins for Malawi
lag2<-lag[!is.na(lagbins)]
vclo2<-vclo[!is.na(lagbins)]
lagbins<-factor(lagbins[!is.na(lagbins)])
nlags<-nlevels(lagbins)
lag2
vclo2
# Check
min(lag2)
max(lag2)
max(bear) # Km
bear<-bear[!is.na(bear)]
max(bear)
max(lag2)/2 # Km
?finalBearing
?distVincentySphere
110/100
110/100/4
110/100/2
110/100/10
# Creating the mesh
# Generating the mesh based on the point locations
mesh <- inla.mesh.2d(loc = coord, max.edge = c(.3, .7), cutoff = c(0.0001))
# Loading libraries
library(INLA) # Modelling (R INLA)
library(sf) # spatial data manipulation
library(spdep) # grid and neighbours
library(dplyr) # data wrangling
# Loading the data
(file <- grep("plasma.*v2.0.0", list.files(here::here("data", "inter-output", "model")),
value = TRUE))
# Distance to the lake
dist <- readRDS(here::here("data", "inter-output", "cluster-distance-to-mwi-lakes.RDS"))
# A list to store the models outputs
models <- list()
# Covariates selection
covar <- c("Se_mean", "wealth_idx", "urbanity", "AGE_IN_YEARS", "crp", "agp",
"dist_to_lake")
i =1
# Loading the data
plasma_se <- readRDS(here::here("data", "inter-output", "model",
file[i])) %>%
# Joining the variable distance to inland water body
left_join(., dist)
# Ensuring cluster is not considered numeric
plasma_se$survey_cluster1 <- as.character(plasma_se$survey_cluster1)
# Renaming variable and checking indv. data
plasma_se <- dplyr::rename(plasma_se, Plasma_Se = "selenium") %>%
# Selecting the variables needed
dplyr::select(Plasma_Se, covar, unique_id, region,
survey_cluster1,  Latitude,  Longitude)
# Excluding NAs
plasma_se <- na.omit(plasma_se)
# Locations
coord <- cbind(plasma_se$Longitude, plasma_se$Latitude)
#Summary of the distance between the locations
summary(dist(coord))
# Creating the mesh
# Generating the mesh based on the point locations
mesh <- inla.mesh.2d(loc = coord, max.edge = c(.3, .7), cutoff = c(0.0001))
plot(mesh, asp=1, main='')
points(coord, col = "red", pch = 1)
r <- 110/100
mesh <- inla.mesh.2d(coord, cutoff=r/10,
max.edge=c(r/4, r/2), offset=c(r/2, r))
plot(mesh, asp=1, main='')
points(coord, col = "red", pch = 1)
# Creating the mesh
# Generating the mesh based on the point locations
mesh <- inla.mesh.2d(loc = coord, max.edge = c(.3, .7), cutoff = c(0.0001))
plot(mesh, asp=1, main='')
points(coord, col = "red", pch = 1)
# Projection matrix (A) obs.
A <- inla.spde.make.A(mesh = mesh , loc = coord)
dim(A)
table(rowSums(A>0))
table(rowSums(A))
summary(rowSums(A))
table(rowSums(A))
